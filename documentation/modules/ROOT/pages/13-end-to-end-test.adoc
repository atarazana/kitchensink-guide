= End To End Test
include::_attributes.adoc[]

[#introduction]
== Introduction

So far, *you have deployed your application and CICD pipelines*; additionally you *have created webhooks* and they are, apparently, working properly but we will never know for sure unless we make a change in the code and see if it all works as expected and we see that change being promoted through our environments. *It's about time for an end to end test!*

The next diagram summarizes the end to end test you are going to run. As you can see, you will make a change to the code of the _Kitchensink Application_ (*kitchensink*) which, via a webhook, will trigger the CI pipeline and hence the promotion of code. 

image::end-to-end-pipeline-1.png[End to End Pipeline Test]

These are the high level sequence of events (only relevant steps are mentioned, more details later on):

1. Change the code and push those changes to the repository of code (*kitchensink* in this case).
2. The *_Push Event_* is sent by the webhook to the *kitchensink CI Pipeline Event Listener* which in its turn triggers the pipeline by creating a *_PipelineRun_* object.
3. The `build` step builds the image for *kitchensink* and pushes it to the registry, the hash of the new image is used to update the _kustomization.yaml_ file in the _dev overlay_, in a short-lived feature-branch in the configuration repository (*kitchensink-conf*)
4. A *_Pull Request_* is created for *merging* the `feature branch` with the `main branch` in the `pr-create` step.
5. The PR has to be confirmed so that changes are effectively merged into the main branch (this is a manual step)
6. Once the PR is confirmed, the merge is effective and a *_Pull Request Event_* is sent by the corresponding webhook to the *kitchensink CD Pipeline Event Listener* which in its turn triggers the pipeline by creating another *_PipelineRun_* object. At this point the hash of the new image has replaced the previous one.
7. The _CD pipeline fetches configuration not code_ and _in parallel triggers the sync of_ *kitchensink-kustomized-helm-app-dev* which means the new hash of the image is replaced in the Deployment object and hence a rolling update is triggered. Once the app is in sync a new PR is created to promote the code to the next environment.

Steps 6 and 7 are repeated for each environment until the code has been promoted to all of them.

Ok, done with the introduction, let's get down to work!

[#current-status]
== Ⓐ Current Status

Before kicking off the demo let's check the current status of *Kitchensink*. In order to do it, please open the next to link in both tabs so that you can watch the status of our app all the way through out the demo.

Use this link to watch the status of *Kitchensink* in `dev`.

[.console-input]
[source,console,subs="+attributes"]
----
{kitchensink-kustomized-helm-dev-host}
----

And this link to watch the status of *Kitchensink* in `test`.

[.console-input]
[source,console,subs="+attributes"]
----
{kitchensink-kustomized-helm-test-host}
----

[#change-the-code]
== Ⓑ Change the code

You're going to make the same change you did in while testing hot reloading in chapter xref:04-s2i.adoc#hot-redeploy[Redeploying a JBOSS EAP application]. This time though you will make the change in the repository of code itself.

Copy the next URL and paste it in a new tab.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{gitea-host}/{username}/kitchensink/_edit/main/src/main/webapp/index.xhtml#L27
----

Around line 27 make the next change:

[source, bash,subs="+macros,+attributes"]
----
<p>You have successfully deployed the JBoss Application in OpenShift</p>
----

With:

[.console-input]
[source, bash,subs="+macros,+attributes"]
----
<p>You have successfully deployed the Kitchensink in OpenShift !!!</p>
----

Commit changes, scroll down, add a commit message and click on the *Commit changes* button.

image::gitea-code-commit-push.png[Commit changes]

[#run-ci-pipeline]
== Ⓒ Run the CI pipeline

The *Push Event* generated by the webhook defined in *kitchensink* repo triggers the pipeline named *kitchensink-ci-pl*. Let's check that out.

Copy the next url to the OpenShift console that should take you to the *Pipelines* area and open it in a new tab. Then have a look to the *kitchensink-ci-pl* pipeline which should have been triggered and hence running.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{openshift-console-host}/dev-pipelines/ns/cicd-tekton-{username}
----

[NOTE]
====
Click on the *PLR* link to see the diagram of the on-going or finished pipeline run; or in the *Task Status Progress Bar* to see the *logs* of tasks and steps.
====

image::kitchensink-ci-pl-1.png[CI Pipeline]

Click on the *PLR* link (red rectangle on the left), eventually you'll see something like this. As you can see this is the representation of the pipeline including the status (in this case all green) of the tasks and also if any of them were skipped (grayed out).

image::kitchensink-ci-pl-2.png[CI Pipeline Run]

Pay attention to the last task. As you can see it is actually two tasks in parallel but only one (`gitea-pr-create`) has been run, the other one (`github-pr-create`) has been skipped because in this case the git provider is Gitea.

This is so because there is a _when expression_ in both tasks checking the GIT_PROVIDER parameter against *github* and *gitea* have a look to both tasks below.

[tabs]
====
github-pr-create::
+
--
[source,yaml, subs="+macros,+attributes"]
----
  - name: github-pr-create
      ...
      runAfter:
        - update-image
      taskRef:
        kind: ClusterTask
        name: github-pr-create
      when: <1>
        - input: $(params.GIT_PROVIDER)
          operator: in
          values:
            - github
----
<1> This task is run if *GIT_PROVIDER* is *github*{empty}footnote:[https://{gitea-host}/{username}/kitchensink-conf/src/branch/main/cicd/templates/03-pipelines/pipeline-ci-pl.yaml#L175]
--
gitea-pr-create::
+
--
[source,yaml, subs="+macros,+attributes"]
----
  - name: gitea-pr-create
      ...
      runAfter:
        - update-image
      taskRef:
        kind: ClusterTask
        name: gitea-pr-create
      when: <1>
        - input: $(params.GIT_PROVIDER)
          operator: in
          values:
            - gitea
----
<1> This task is run if *GIT_PROVIDER* is *gitea*{empty}footnote:[https://{gitea-host}/{username}/kitchensink-conf/src/branch/main/cicd/templates/03-pipelines/pipeline-ci-pl.yaml#L210]
--
====

So if the pipeline has finished well, the new image should have been pushed to the internal registry. Additionally the `kustomization.yaml` file of the `dev` overlay has been updated with the hash of the new image in a short-lived feature branch and finally a PR should have been created.

Let's check all that out, let's start with the image. Copy the following link and open it in a browser.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{openshift-console-host}/k8s/ns/cicd-tekton-user30//imagestreamtags/kitchensink:latest/history
----

You should see an image recently pushed as in the next picture.

NOTE: If you click on the `download` icon and then choose `Docker Pull (by digest)` you can find the SHA256 has at the end of the command.

image::imagestream-history.png[New Image]

Now it's time to check it the PR has been created and includes the change of `kustomization.yaml` as expected.

Please copy this link and open it.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{gitea-host}/{username}/kitchensink-conf/pulls
----

You should see something like this, please click on the open PR.

image::dev-pr-1.png[Pull Requests]

In the body of the PR there's information that helps the person who is to approve the PR that also will be used by the CD pipeline which should be triggered once the PR has been merged.

image::dev-pr-2.png[Open PR]

Please go ahead and have a look to the `±Files changed` area. Once you're done click on the `Conversation` link.

NOTE: You should see changes made to file `./events-deployment/overlays/dev/kustomization.yml`.

image::dev-pr-3.png[Files changed]

Ok, both the image and the PR are where they're supposed to be, let's move on!

[#running-cd-pipeline-dev]
== Ⓓ Run the CD pipeline (`dev`)

So the CI pipeline has prepared everything to start with the actual deployment of a new version of the Kitchensink service. If you weren't using GitOps the CD pipeline would (probably after an Approval Task) start by updating the image in the `Deployment` object using the Kubernetes API, but that's not the case here. The Approval Task you would use in a Jenkins pipeline has been replaced by a PR and changes to the `Deployment` object in the OpenShift cluster have been replaced by ArgoCD reconciling changes from the source of truth (git repository) to the OpenShift cluster.

[#approving-pr-dev]
=== Approve PR

Well, it's time to continue where we left it, so go back to the PR and click on the `Create Merge Commit` then tick the `Delete Branch` check-box (we wont need that branch anymore) and click again on `Create Merge Commit`.

[#cd-pipeline-triggered-dev]
=== CD Pipeline Triggered

The *Pull Request* event is sent out by the webhook to the *Kitchensink CD Pipeline `EventListener`* where some mapping and filtering will trigger the pipeline with a `PipelineRun` object populated with the necessary information.

Please, open the next link or navigate to *Pipelines* in project `tekton-cicd-{username}` you will see the pipeline progressing.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{openshift-console-host}/dev-pipelines/ns/cicd-tekton-{username}
----

NOTE: As you have done previously you can click on the *PLR* object to drill down and have a look to the logs.

Have a look at the pipeline details. As you can see there are several tasks, namely:

- `argocd-sync` triggers the refresh and sync of descriptors coming from the corresponding overlay{empty}footnote:[https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/#bases-and-overlays], `dev` in this case
- `fetch-config-repository` clones the `kitchensink-conf` configuration repository
- `update-image` creates a short-lived branch and updates the image hash in the `kustomization.yaml` file for the corresponding overlay
- `github-pr-create` creates a PR for Github (not run)
- `gitea-pr-create` creates a PR for Gitea

[#argocd-app-synced-dev]
=== ArgoCD App Synced

Open the following link to see the new Application objects you just created through the ApplicationSet in ArgoCD UI.

[.console-input]
[source,url, subs="+attributes"]
----
https://{argocd-server}/applications?labels=username%253D{username}%2Ckustomized-helm%253Dtrue
----

[#checking-openshift-console-dev]
=== Checking OpenShift Console

Use this link to watch the status of *Kitchensink  `dev` namespace*.

[.console-input]
[source,url, subs="+attributes"]
----
https://{openshift-console-host}/topology/ns/helm-kustomize-dev-{username}?view=graph
----

[#checking-kitchensink-status-dev]
=== Checking Kitchensink Status in `dev`

Use this link to watch the status of *Kitchensink Application* in `dev`.

[.console-input]
[source,console,subs="+attributes"]
----
{kitchensink-kustomized-helm-dev-host}
----

[#running-cd-pipeline-test]
== Ⓔ Run the CD pipeline (`test`)

This time we're going to do this a bit faster and with less talking. This chapter is essentially the same as the previous one, but if you have access to an additional cluster and you have run section xref:04-prepare-argocd.adoc#register-additional-clusters[Register Additional Clusters], then you will see how *Kitchensink* is also updated in the additional cluster.

[#approving-pr-test]
=== Approve PR

Open the Pull Requests area in the kitchensink-conf as you did before, have a look to the modified files and then approve it:

[.console-input]
[source,bash, subs="+attributes"]
----
https://{gitea-host}/{username}/kitchensink-conf/pulls
----

[#cd-pipeline-triggered-test]
=== CD Pipeline Triggered

Use the the next link or navigate to *Pipelines* in project `tekton-cicd-{username}` you will see the pipeline progressing.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{openshift-console-host}/dev-pipelines/ns/cicd-tekton-{username}
----

[#argocd-app-synced-test]
=== ArgoCD App Synced

Open the following link to see how this time the `test` variant is the one being synced.

[.console-input]
[source,url, subs="+attributes"]
----
https://{argocd-server}/applications?labels=username%253D{username}%2Ckustomized-helm%253Dtrue
----

[#checking-openshift-console-test]
=== Checking OpenShift Console

Use this link to watch the status of *Kitchensink  `test` namespace*.

[.console-input]
[source,url, subs="+attributes"]
----
https://{openshift-console-host}/topology/ns/helm-kustomize-test-{username}?view=graph
----

[#checking-kitchensink-status-test]
=== Checking Kitchensink Status in `test`

Use this link to watch the status of *Kitchensink Application* in `test`.

[.console-input]
[source,console,subs="+attributes"]
----
{kitchensink-kustomized-helm-test-host}
----